import fs from 'fs/promises';
import { z } from 'zod';
import path from 'path';
import { config } from './config.js';
import { SummaryData, SummaryFileInfo } from './types.js';
import {
  ensureSummariesDir,
  generateFilename,
  generateTimestamp,
  findFileBySessionId,
  findAllFilesBySessionId,
  writeSummaryFile,
  readSummaryFile,
  deleteFile,
  getSummaryFiles,
  loadSummaryData
} from './storage.js';

// Get session history with all versions
export async function getSessionHistory(params: { sessionId: string }, extra: any) {
  try {
    const { sessionId } = params;
    
    // Get all files for this session
    const fileInfos = await findAllFilesBySessionId(sessionId);
    
    if (fileInfos.length === 0) {
      return {
        content: [{ 
          type: "text" as const, 
          text: JSON.stringify({ 
            success: false, 
            error: `No history found for session ${sessionId}` 
          }) 
        }],
        isError: true
      };
    }
    
    // Load data for all files
    const loadedInfos = await loadSummaryData(fileInfos);
    
    // Extract relevant information
    const history = loadedInfos
      .filter(info => info.loaded && info.data)
      .map(info => ({
        timestamp: info.timestamp,
        lastUpdated: info.data!.lastUpdated,
        title: info.data!.title || null,
        tags: info.data!.tags || [],
        summaryLength: info.data!.summary.length,
        summary: info.data!.summary
      }));
    
    return {
      content: [{ 
        type: "text" as const, 
        text: JSON.stringify({ 
          success: true, 
          sessionId,
          versionCount: history.length,
          history
        }) 
      }]
    };
  } catch (error) {
    process.stderr.write(`Error in getSessionHistory: ${error}\n`);
    return {
      content: [{ 
        type: "text" as const, 
        text: JSON.stringify({ 
          success: false, 
          error: String(error) 
        }) 
      }],
      isError: true
    };
  }
}

// Schema for upsertSummary tool
export const upsertSummarySchema = z.object({
  sessionId: z.string().min(1).describe(
    "**Mandatory.** A unique identifier for the conversation session. " +
    "**It is the client application's responsibility to generate this ID.** " +
    "It should be generated once at the beginning of a new logical conversation session. " +
    "**Recommendation:** Use a standard **UUID (Version 4)** library available in your " +
    "programming language to ensure uniqueness. The client must then reuse the *same* " +
    "generated ID for all subsequent `upsertSummary` calls pertaining to that specific session."
  ),
  summary: z.string().describe(
    "**Mandatory.** The detailed content of the session chronicle/log. " +
    "This should contain rich information beyond a brief summary, as generated by the client or LLM. " +
    "Each call will create a new version in the session history rather than overwriting previous versions."
  ),
  title: z.string().optional().describe(
    "A short, descriptive title for the session."
  ),
  tags: z.array(z.string()).optional().describe(
    "Keywords or tags to categorize the session."
  )
});

// Schema for getSummary tool
export const getSummarySchema = z.object({
  sessionId: z.string().min(1).describe(
    "The unique ID of the session summary to retrieve. This will return only the latest version. " +
    "To retrieve all versions, use the getSessionHistory tool instead. " +
    "**If omitted, the tool will list available summaries instead (fallback to listSummariesTool logic).**"
  ),
  maxLength: z.number().int().positive().optional().describe(
    "If provided, truncate the retrieved summary text to this maximum length."
  )
});

// Schema for listSummaries tool
export const listSummariesSchema = z.object({
  tag: z.string().optional().describe(
    "Filter summaries by a specific tag."
  ),
  limit: z.number().int().positive().optional().describe(
    "Limit the number of results returned."
  ),
  offset: z.number().int().nonnegative().optional().default(0).describe(
    "Offset for pagination."
  ),
  sortBy: z.enum(['lastUpdated', 'title']).optional().default('lastUpdated').describe(
    "Field to sort by ('lastUpdated' leverages filename sorting)."
  ),
  order: z.enum(['asc', 'desc']).optional().default('desc').describe(
    "Sort order ('desc' for most recent first)."
  )
}).optional();

// Schema for updateMetadata tool (optional)
export const updateMetadataSchema = z.object({
  sessionId: z.string().min(1).describe(
    "**Mandatory.** The unique ID of the session whose metadata to update."
  ),
  title: z.string().optional().describe(
    "New title. If omitted, title remains unchanged."
  ),
  tags: z.array(z.string()).optional().describe(
    "New tags array. If omitted, tags remain unchanged."
  )
}).refine(
  data => data.title !== undefined || data.tags !== undefined, 
  { message: "At least one metadata field (title or tags) must be provided to update." }
);

// Implementation for upsertSummary tool - saving historical versions
export async function upsertSummary(params: z.infer<typeof upsertSummarySchema>, extra: any) {
  try {
    await ensureSummariesDir();
    
    const { sessionId, summary, title, tags } = params;
    
    // Generate new timestamp and filename
    const newTimestamp = generateTimestamp();
    const newFilename = generateFilename(sessionId, newTimestamp);
    const newFilePath = path.join(config.summariesDir, newFilename);
    
    // Prepare the data to store
    const dataToStore: SummaryData = {
      sessionId,
      summary,
      lastUpdated: new Date().toISOString()
    };
    
    // Add optional fields if provided
    if (title !== undefined) dataToStore.title = title;
    if (tags !== undefined) dataToStore.tags = tags;
    
    // Write operation - only write the new file, don't delete old versions
    await writeSummaryFile(newFilePath, dataToStore);
    
    return {
      content: [{ 
        type: "text" as const, 
        text: JSON.stringify({ 
          success: true, 
          message: `Summary created for session ${sessionId}`,
          timestamp: newTimestamp
        }) 
      }]
    };
  } catch (error) {
    process.stderr.write(`Error in upsertSummary: ${error}\n`);
    return {
      content: [{ 
        type: "text" as const, 
        text: JSON.stringify({ 
          success: false, 
          error: String(error) 
        }) 
      }],
      isError: true
    };
  }
}